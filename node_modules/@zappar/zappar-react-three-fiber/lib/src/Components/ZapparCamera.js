"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ZapparThree = __importStar(require("@zappar/zappar-threejs"));
const react_1 = __importStar(require("react"));
const react_merge_refs_1 = __importDefault(require("react-merge-refs"));
const fiber_1 = require("@react-three/fiber");
const store_1 = __importDefault(require("../store"));
class ZapparCameraAdditional extends ZapparThree.Camera {
    constructor() {
        super(...arguments);
        this.updateProjectionMatrix = () => { };
    }
}
// First frame rendered R3f tries to update the projection matrix of the default camera.
// Zappar camera does not have this method, so we create a noop
fiber_1.extend({ ZapparCameraAdditional });
/**
 * Creates a camera that you can use instead of a perspective camera.
 *
 * @see https://docs.zap.works/universal-ar/web-libraries/react-threejs/camera-setup/
 */
const ZapparCamera = react_1.forwardRef((props, ref) => {
    const { userFacing = false, rearCameraMirrorMode, userCameraMirrorMode, poseMode, poseAnchorOrigin, pipeline, sources, makeDefault = true, renderPriority = 1, permissionRequest = true, onFirstFrame, environmentMap, useEnvironmentMap, } = props;
    const { gl, scene, set } = fiber_1.useThree((state) => state);
    const [hadFirstFrame, setHadFirstFrame] = react_1.useState(false);
    const cameraRef = react_1.default.useRef();
    const [envMap, setEnvMap] = react_1.useState();
    const [permissionGranted, setPermissionGranted] = react_1.useState(false);
    const store = {
        camera: store_1.default.camera((state) => state),
    };
    react_1.useEffect(() => {
        const activePipeline = pipeline || ZapparThree;
        activePipeline.glContextSet(gl.getContext());
    }, [pipeline, gl]);
    // TODO: If not making default, scene's texture should not be changed, and camera should not tick.
    // TODO: Instead, it should be exposed to user to set when needed.
    react_1.useLayoutEffect(() => {
        if (makeDefault) {
            set(() => ({ camera: cameraRef.current }));
        }
    }, [makeDefault]);
    react_1.useEffect(() => {
        if (environmentMap || useEnvironmentMap) {
            const envMap = new ZapparThree.CameraEnvironmentMap();
            if (environmentMap)
                scene.environment = envMap.environmentMap;
            useEnvironmentMap === null || useEnvironmentMap === void 0 ? void 0 : useEnvironmentMap(envMap.environmentMap); // Overlap with THREE.texture
            setEnvMap(envMap);
        }
    }, [environmentMap]);
    react_1.useEffect(() => {
        if (!cameraRef.current)
            return;
        store.camera.set(cameraRef.current);
        scene.background = cameraRef.current.backgroundTexture;
        if (permissionGranted || !permissionRequest) {
            cameraRef.current.start(userFacing);
        }
        else {
            ZapparThree.permissionRequestUI().then((granted) => {
                setPermissionGranted(granted);
                if (granted)
                    cameraRef.current.start(userFacing);
                else
                    ZapparThree.permissionDeniedUI();
            });
        }
    }, [userFacing, permissionRequest]);
    react_1.useEffect(() => {
        if (!cameraRef.current)
            return;
        switch (rearCameraMirrorMode) {
            case "poses":
                cameraRef.current.rearCameraMirrorMode = ZapparThree.CameraMirrorMode.Poses;
                break;
            case "css":
                cameraRef.current.rearCameraMirrorMode = ZapparThree.CameraMirrorMode.CSS;
                break;
            case "none":
            default:
                cameraRef.current.rearCameraMirrorMode = ZapparThree.CameraMirrorMode.None;
                break;
        }
        switch (userCameraMirrorMode) {
            case "none":
                cameraRef.current.userCameraMirrorMode = ZapparThree.CameraMirrorMode.None;
                break;
            case "css":
                cameraRef.current.userCameraMirrorMode = ZapparThree.CameraMirrorMode.CSS;
                break;
            case "poses":
            default:
                cameraRef.current.userCameraMirrorMode = ZapparThree.CameraMirrorMode.Poses;
                break;
        }
        switch (poseMode) {
            case "anchor-origin":
                cameraRef.current.poseMode = ZapparThree.CameraPoseMode.AnchorOrigin;
                cameraRef.current.poseAnchorOrigin = poseAnchorOrigin;
                break;
            case "attitude":
                cameraRef.current.poseMode = ZapparThree.CameraPoseMode.Attitude;
                break;
            case "default":
            default:
                cameraRef.current.poseMode = ZapparThree.CameraPoseMode.Default;
                break;
        }
    }, [rearCameraMirrorMode, userCameraMirrorMode, poseMode, poseAnchorOrigin]);
    fiber_1.useFrame(({ gl, scene }) => {
        if (!cameraRef.current)
            return;
        if (onFirstFrame && !hadFirstFrame && cameraRef.current.pipeline.frameNumber() > 0) {
            setHadFirstFrame(true);
            onFirstFrame();
        }
        cameraRef.current.updateFrame(gl);
        envMap === null || envMap === void 0 ? void 0 : envMap.update(gl, cameraRef.current);
        gl.render(scene, cameraRef.current);
    }, renderPriority);
    return (react_1.default.createElement("zapparCameraAdditional", Object.assign({ args: [{ pipeline, userCameraSource: sources === null || sources === void 0 ? void 0 : sources.userCamera, rearCameraSource: sources === null || sources === void 0 ? void 0 : sources.rearCamera }], ref: react_merge_refs_1.default([cameraRef, ref]) }, props)));
});
exports.default = ZapparCamera;
